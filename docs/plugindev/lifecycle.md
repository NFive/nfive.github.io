---
title: Life Cycle
---

The guide explains the life cycle for NFive plugins and details the main classes and functionality.

---

# Server Side
Server side NFive plugins must contain one or more classes inheriting from the `Controller` class, however most plugins will only consist of one. When starting up, the NFive server will create an instance of each compatible controller class it finds in the server plugin assembly.

## Life Cycle
1. Plugin controllers are constructed early in the NFive startup process and the order plugins are loaded cannot be guaranteed, so you should not use the constructor for any plugin runtime logic.
2. Immediately after the plugin's constructor is called, NFive invokes the plugin's `Loaded()` method.
3. Once all plugins are loaded, all controllers' `Started()` methods are invoked in parallel asynchronously.
4. The server fires off internal events signalling that it has finished loading.

## Controller
**`NFive.SDK.Server.Controllers.Controller`**

<AUTOGENERATED_TABLE_OF_CONTENTS>

### Constructor
```csharp
Controller(ILogger logger, IEventManager events, IRpcHandler rpc, IRconManager rcon)
```
A controller's constructor also supports dependency injection via arguments, allowing for dynamic plugin interface sharing. For convenience the logger, events, RPC and RCON types are always provided and stored to local properties for easy access.

### Methods

### `Loaded()`
```csharp
void Loaded()
```
Run immediately after the plugin's constructor is called, provided for continence so that asynchronous code can be used during construction. NFive server will block and wait for this method to complete before loading the next plugin.

---

### `Started()`
```csharp
void Started()
```
Run asynchronously at the same time for all plugins after they have all been loaded. This method is where all plugin startup logic should be ran.

---

### `Reload()`
```csharp
void Reload()
```
Triggered by user request, this method should run code to reset and reload any plugin configuration or cache.

## Configurable Controller
**`NFive.SDK.Server.Controllers.ConfigurableController<T : IControllerConfiguration>`**

NFive also provides a subclass of `Controller`, `ConfigurableController<T>` for convenience. The configurable controller allows you to supply a model type which will automatically be used as the plugin's configuration object and be loaded from a YAML file.

### Constructor
```csharp
ConfigurableController<T>(ILogger logger, IEventManager events, IRpcHandler rpc, IRconManager rcon, T configuration)
```
The configurable controller constructor is the same as the standard controller except that the 5th argument will be an instance of the provided configuration type. This instance is created by NFive deserializing the plugin YAML configuration file at startup, which is stored in a local property.

### Methods
The configurable controller has the same methods as the standard controller except for `Reload()`.

### `Reload()`
```csharp
void Reload(T configuration)
```
The configurable controller is provided with a newly read and loaded from disk configuration object and by default updates the local configuration property.

## Constructor Dependency Injection
Along with the standard parameters for a controller type, it is possible for a plugin to specify extra constructor interface parameters which the NFive server will provide at runtime.

Using this feature along with nested plugin dependencies its possible for one plugin to get an instance of a class provided in another plugin.

The dependency inject system works with both transient and singleton instances allowing for separate or shared instance across plugins.

### Component Registration
In order for a type to be resolvable by the injection system, the type must be marked as a "component", which is done with the `ComponentAttribute`.

#### NFive Components
* ILogger
* IEventManager
* IRpcHandler
* IRconManager

#### Example
Plugin "XYZ":
```csharp
public interface IXyzUtility
{
    void Run(string msg);
}

// Mark class as a component so it can be requested by other plugins
// and as transient so a separate instance is created for each plugin
[Component(Lifetime = Lifetime.Transient)]
public class XyzUtility : IXyzUtility
{
    private ILogger logger;

    // Components are able to utilize the dependency injection system themselves,
    // requesting other registered components
    public XyzUtility(ILogger logger)
    {
        this.logger = logger;

        this.logger.Debug("Utility created");
    }

    public void Run(string msg)
    {
        this.logger.Debug($"Utility ran: {msg}");
    }
}
```

Plugin "ABC" which has a dependency on "XYZ":
```csharp
public class AbcController : Controller
{
    // Must request the external interface
    public AbcController(ILogger logger, IEventManager events, IRpcHandler rpc, IRconManager rcon, IXyzUtility utility)
      : base(logger, events, rpc, rcon)
    {
        // Invoke the external code
        utility.Run("Hello world");
    }
}
```
